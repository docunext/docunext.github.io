{"data":{"markdownRemark":{"html":"<p>The Sinatra configuration capacity has always mystified me, but I think I've found the code I need to review to understand how its done.</p>\n<p>First, look at the set method:</p>\n<pre class=\"sh_ruby\">\n     # Sets an option to the given value.  If the value is a proc,\n      # the proc will be called every time the option is accessed.\n      def set(option, value=self, &block)\n        raise ArgumentError if block && value != self\n        value = block if block\n        if value.kind_of?(Proc)\n          metadef(option, &value)\n          metadef(\"#{option}?\") { !!__send__(option) }\n          metadef(\"#{option}=\") { |val| metadef(option, &Proc.new{val}) }\n        elsif value == self && option.respond_to?(:to_hash)\n          option.to_hash.each { |k,v| set(k, v) }\n        elsif respond_to?(\"#{option}=\")\n          __send__ \"#{option}=\", value\n        else\n          set option, Proc.new{value}\n        end\n        self\n      end\n</pre>\n<p>Talk about rock and roll, OK? But wait, there's more. The metadef:</p>\n<pre class=\"sh_ruby\">\n      def metadef(message, &block)\n        (class << self; self; end).\n          send :define_method, message, &block\n      end\n</pre>\n<p>Do you think metadef sounds better than metameth?</p>","frontmatter":{"title":"Sinatra Metadef","date":"March 23rd, 2010"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2010/2010-03-23-sinatra-metadef/"}}