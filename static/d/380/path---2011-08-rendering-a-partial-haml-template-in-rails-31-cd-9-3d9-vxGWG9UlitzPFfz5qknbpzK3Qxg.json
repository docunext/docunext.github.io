{"data":{"markdownRemark":{"html":"<h4>How To Render a Partial HAML Template From a Rake Task in Rails 3.1</h4>\n<p>Thanks to <a href=\"http://mamykin.com/2011/06/28/how-to-render-view-from-rake.html\">Klimant Mamykin</a>, I was able to figure out how to render a partial HAML template in Rails 3.1.</p>\n<p>My setup is a little different, as I'm trying to render a controller independent partial:</p>\n<pre class=\"sh_ruby\">\nnamespace :render do\n  task :partials => :environment do\n    app = RegdelRails::Application\n    controller = AccountsController.new\n    view = ActionView::Base.new(app.config.paths.app.views.first)\n    view.class_eval do\n      include ApplicationHelper\n      include app.routes.url_helpers\n    end\n    Dir[\"#{Rails.root}/app/views/layouts/_*.html.haml\"].each do |file_name|\n      puts file_name\n      if File.exist?(file_name)\n        new_file = file_name.gsub('.haml','')\n        output = view.render 'layouts/header'\n        f = File.new(new_file, \"w\")\n        f.write(output)\n      end\n    end\n  end\nend\n</pre>\n<p>Why am I bothering to do this? I want to use Rack::XSL, but also support operation of my Rails 3.1 apps without requiring Rack::XSL, as it can be a pain to install, and some people simply don't like XSL at all.</p>\n<p>Why do I like XSL? Its incredibly fast, and supports caching, so it can be a big performance booster for heavy Rails apps.</p>\n<p>Here's an updated version that supports javascript and css tags, as well as csrf-tokens:</p>\n<pre class=\"sh_ruby\">\nnamespace :render do\n  task :partials => :environment do\n    request = {\n     \"SERVER_PROTOCOL\" => \"http\",\n     \"REQUEST_URI\" => \"/\",\n     \"SERVER_NAME\" => \"localhost\",\n     \"SERVER_PORT\" => 80\n    }\n    app = RegdelRails::Application\n    view = ActionView::Base.new(app.config.paths.app.views.first)\n    view.config = Rails.application.config.action_controller\n    view.extend ApplicationController._helpers\n    view.controller = ActionController::Base.new\n    view.controller.request = ActionDispatch::Request.new(request)\n    view.controller.response = ActionDispatch::Response.new\n    view.controller.headers = Rack::Utils::HeaderHash.new\n    view.class_eval do\n      include ApplicationHelper\n      include app.routes.url_helpers\n    end\n    view.controller.class_eval do\n      include ApplicationHelper\n      include app.routes.url_helpers\n    end\n    Dir[\"#{Rails.root}/app/views/layouts/_*.html.haml\"].each do |file_name|\n      puts file_name\n      if File.exist?(file_name)\n        new_file = file_name.gsub(\"#{Rails.root}/app/views/layouts/_\",'app/views/layouts/xsl/html/').gsub('.haml','')\n        output = view.render file_name.gsub(\"#{Rails.root}/app/views/layouts/_\",'layouts/').gsub('.html.haml','')\n        f = File.new(new_file, \"w\")\n        f.write(output)\n      end\n    end\n  end\nend\n</pre>\n<p>After I succeeded in making this happen, I learned about the awesome new block and partial caching capabilities of Rails 3 - I am so impressed by it! I plan to write an article on that soon.</p>\n<p>Still - use of Rails 3 caching does not solve the problem of mixing HAML partials with Rack served static HTML. For example, I'm starting to use ditz with Regdel. Ditz can generate project report pages - but what if I want them integrated into my application? Same with Rcov, too.</p>","frontmatter":{"title":"Rendering A Partial HAML Template in Rails 3.1","date":"August 30th, 2011"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2011/08/rendering-a-partial-haml-template-in-rails-31/"}}