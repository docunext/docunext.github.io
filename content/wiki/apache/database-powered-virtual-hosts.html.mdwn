### Introduction
With mod_rewrite, you can store your virtual host configuration in a relational database. How cool is that? You use the relatively new RewriteMap function to connect to a database via the "prg:" option, like so:

<pre>
#!/usr/bin/perl
use DBI;
$|=1;

$token = "\/";

@uri = split(/$token/, <STDIN>, 2);

print @uri[0];
print @uri[1];

my $dbh = DBI->connect('DBI:mysql:your-database-name-here:127.0.0.1','your-user-name-here', 'your-password-here');
$dbh->{mysql_auto_reconnect} = 1;
my $sth = $dbh->prepare("SELECT value FROM column
                        WHERE key = ?");
my $rw_value;

while (my $post_name = <STDIN>) {
    chomp $post_name;
    $sth->execute($post_name);
    $sth->bind_columns(\$rw_value);
    $sth->fetch;
        if($rw_value) {
        print "$rw_value\n";
        } else {
        print "nomatch\n";
        }
$rw_value       = "nomatch";
}
</pre>

In the apache conf, I have this:

<pre>
        RewriteMap redirects prg:/etc/apache2/lookitup.pl
        RewriteCond ${redirects:%{HTTP_HOST}|nomatch} !nomatch
        RewriteRule (.*) http://${redirects:%{HTTP_HOST}} [R=301,L]
</pre>

The apache conf information is used to define the program (it's started upon Apache startup, and stays running), check to see if the key finds anything, and then redirect if it doesn't. I'm planning to modify it so that it is faster, though I'm not sure how yet!

### Ideas
#### Possibilities
* Does it make sense to have non-blocking code used here to make sure the server isn't waiting for the database? Not sure, need to do some testing on it for performance.
* Could memcached be used for caching the lookups? - Yes, I am doing so now, but it seems to slow down at some points.
* Need a database lookup for each type of rewrite rule: R, PT, QSA, etc.?
* And / or redirects based upon io: domain redirects versus url redirects, domain-specific redirects...
* This is kind of like a layer7 router, does it make sense to put it on a dedicated apache server?

#### Storing Data for Output to Flat Files
I'm now using a database to store rewrite data, which is then output to plain text file for conversion to a dbm hash file. This is good for me because it centralizes management, yet keeps this fast and reliable.

So far I'm only doing this with domain redirects, but I'm planning on setting it up for proxies too. But I think with regards to storing the logic in a database, it only makes sense to do so for domains, redirects, and proxies, not paths redirects or rewrites.

Path redirects are a little challenging. For instance, due to poor planning, I'm eventually going to need to migrate the http:www.informedbanking.com/ wiki paths from /acc/nxwiki/view/ to simply /wiki/. Its easy to write this out with mod_rewrite, but how could it be stored in a database? Should it be even? Instead of using mod_rewrite to access this information in a database, perhaps it would be better to build an optimized version of the regular expression, needed to accomplish the task.

Path Rewrites (no redirects): Just to remind myself - I'm doing this for publicity. I believe that url paths are an important part of communicating with visitors, so while I'm OK with crazy complicated urls, I want there to be a publicly accessible and search engine indexed welcome url. To do this, links must be built a certain way, and the web server must be able to parse the string in such a way as to correlate it back to the database.

#### Problems
#### Regex Matching URLs to a database of URLs
The main problem I've encountered here is that even though a single query can lookup a hostname and URL, it can't effectively lookup regex matches for a few reasons. I'd want to put the regex pattern in the database, but using a LIKE SQL statement can't match approximate the data to the query string. For example, say you want to match all urls that start with "/2007/" for a certain domain. To match those for only a single domain, you'd need the ability to pass the full URL (example.com/2007/foo.html) as a query string, and have the SQL query match it against a partial stored (/2007/%) in the database. That's backwards, you'd usually query the DB with the partial (SELECT * FROM bar WHERE field LIKE '/2007/%').

To work around this problem, you could set some parameters for querying the database. For example, say your urls are structured using the forward slash as a categorization divider, as suggested above. The documents prefixed with /2007/ would be different than /2006/, and so on. If you need to match partially, you could set "/" as a token to split the url, and send a depth of tokens to match. If you don't have that straightforward of URL structures, you could elect to query the database for certain domains with a subset of the characters in the url, say the first 15 characters. This is tricky though because you might end up with false positive matches.

The following would provide only the first token to be matched against what's stored in the database to for example rewrite /2007/anything... to /archive/2007/.
<pre>
RewriteMap foobar prg:lookitup.pl
RewriteCond %{REQUEST_URI} ^/..../
RewriteRule ^/..../(.*) ${foobar:%{HTTP_HOST}%1}
</pre>

Remember that rewriting order matches, so you'd want to start specific and generalize as you progress, so that you can have exclusions to your general rules and avoid the false positive matches. The downside to that method is that the more specific you get, the more processor intensive the matching algorithms get, so you'd want to keep the connection pools open, the result sets cached, and even the http headers cached in apache's shared memory.

My goal with this writing was to find a way to keep my rules simple and general and my data specific and detailed. I don't know enough about Apache modules or C to create some hooks from mod_rewrite to mod_dbd, but I also don't want to have too many external scripts to maintain, or too complex rewrite rules to deal with.

#### Rewrite Using Remainder of a Partial Match
The problem with the above possible solution is that it cannot really handle a dynamic response for matching purposes. This isn't terrible, but it is an issue. Say for example, you wanted to redirect www.example.com/2007/.* to www.example.com/archive/2007/.*, i.e. insert "archive" before "2007", but for archive.example.com/2007/.* you wanted to redirect to a single page: archive.example.com/purged/closed.html. These two database lookups cannot be used with the same rule, unless you used a workaround like included ?from= at the end of the redirect target so that the partial match remainder would only be appended to the url as a get parameter. Although its kind of goofy, that's actually not too bad of a solution.

It would be great to be able to include back-references in the database targets, but I can't imagine that it could work. In that case, for the first example, the external script would lookup "/2007", and the database would respond with "/archive/2007/$1", and mod_rewrite would replace $1 with the partial match specified in the pattern of the rule.  Maybe this will work, but I doubt it.

Indeed, storing a back-reference in the database does not work. Apache redirects the browser to a url with the back-reference appended as it is, without replacing it with a string. We could add another RewriteRule to replace it though. I just edited my external lookup program to replace $1 with the original url, and it seems to work well. The response is picked up and stored in memcached, and presumably in the mod_cache_mem headers. Cool. True, this method is still pretty limited, but if you plan out your urls with some forethought, you should be OK. Remember that first "directory" is a doosey.

### External Links
This code was based on the following post at ONLamp.com:
* http://www.onlamp.com/pub/a/apache/2005/04/28/apacheckbk.html
mod_rewrite includes hooks to mod_dbd in the apache trunk!:
* http://httpd.apache.org/docs/trunk/mod/mod_rewrite.html#rewritemap
* http://www.rob-schulze.de/publikationen/frickelworx/mod_vhost_cdb/