### Thoughts
I'm finding myself using multiple web servers and [[proxies]] more and more these days. Currently I use [[Apache]], [[NGINX]], [[Pound]], and [[Varnish]]. I'm also finding a need to start standardizing the way I configure these servers, so I'm just jotting down some notes here:
#### Port Numbers
* [[Varnish]]: 80, 6081, or 8080
* [[NGINX]]: port 88
* [[Apache]]: 80 or 8080
* [[Pound]]: 443 or 8443

#### Port Numbers Revisited
I'm not using this setup yet, but I'd like to very soon
* [[NGINX]]: 80 or 443 - for compressed content
* [[Apache]]: '''88''' or 8080 - for dynamic content
* [[Varnish]]: 6081 - for cached content
* [[Pound]]: 443 - for encrypted content

#### Application Port Numbers
What about [[FastCGI]] and application-specific webservers?
* [[FastCGI]]: Sockets, such as /var/something or 300x
* [[Unicorn]]: Sockets, such as /var/something or 300x

### A Layered Approach
# Reverse proxy ([[Varnish]]) - keep the vcl as simple as possible with grace periods and failover (restarts)
# Filtering and routing proxy ([[NGINX]]) - more complex, including routing to different backends, filters, and compression, some simple fastcgi applications
# Application server ([[Apache]]) - most complex, including database connectivity

Now that I'm putting caching proxies in front of [[Apache]], I've switched to using [[apache2-mpm-prefork]] instead of [[apache2-mpm-worker]] on most of my servers since it uses a lot less memory.

#### My Experience with "A Layered Approach"

#### Q3 2009
Some hurdles, but all in all its working quite well. I prefer static files and [[NGINX]] does and amazing job with serving clients, so I'm putting it back on the front lines (see [http://www.proxy-sys.com/blog/2009/08/up-front-varnish-or-nginx.html varnish v. nginx] for more on this). [[NGINX]] takes care of compression for HTML files, and with that as the last step, [[Varnish]] can work its magic with [[ESI]]! Its a high-performance, efficient, and scalable static content delivery network, in my humble opinion.

What about dynamic content? In my experience, I've had to work at making a simple separation between dynamic and static content, so I try to keep all dynamic content in a cgi-bin folder, prefaced with /a/, /dyn/, or accessible only with HTTP authentication. That way, whatever various proxies are available should automatically direct dynamic requests to the right backend server.

Let's talk about the back end servers I'm using these days (Q3 2009). I'm still using [[Apache2]] and [[mod_fcgid]], and quite satisfied. I found one gotcha with [[mod_fcgid]] regarding timeouts, and as stated above I've switched to [[apache2-mpm-prefork]]. While idling it uses less memory, but it can quickly spin out of control with badly behaved clients, so I found it important to make sure that requests sent to [[Apache2]] are legitimate.

Still, I wish there were alternatives to the [[Apache2]] + [[mod_fcgid]] combination. The [[spawn-fcgid]] tool from [[Lighttpd]] is awesome, but I haven't felt comfortable with using it in production yet. I need to try setting it up with [[daemontools]].

#### Q4 2009
I don't have this setup yet, but these are my plans. From the back-end to the front:
* Port 8080 - Static files: I'm looking at [[webfs]] as the initial bridge between the [[file system]] and [[HTTP]] for non-negotiable static files, like media files.
* Port 88 - Dynamic content: [[NGINX]] for self-managing [[fastcgi]] processes and [[thttpd]] for [[CGI]] requests and respawning self-managing processes. [[Apache2]] and [[mod_fcgid]] for managing other [[fastcgi]] processes.
* Port 888 - [[CGI]] via [[thttpd]]
* Port 8088 - Content filtering: I am using [[NGINX]] and its [[XSLT]] and [[GD]] plugins, but [[Apache2]] has some terrific filtering capabilities as well. I'm interested in a [[Markdown]] filter, maybe with [[Discount]].
* Port 82 - Redirection: [[Apache2]] and [[mod_rewrite]] - or use lighttpd via 81.
* Port 81 - Complex rewriting and virtual hosts: [[Lighttpd]] and [[mod_magnet]]. - CHECK!
* Port 6081 - Caching proxies, [[ESI]], and initial request routing: [[Varnish]]!
* Port 80 - Global static files, simple virtual hosts, connection management, compression, and delivery to end-user: [[NGINX]].

#### Q1 2010
I'm also using separate servers for different application types:

* Standard applications that are packaged from [[Debian]], like [[Movable Type]] and [[MediaWiki]]
* Custom applications that are not packaged but deployed using [[Vlad]]