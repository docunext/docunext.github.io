{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/2009/11/ruby-datamapper-associations/",
    "result": {"data":{"site":{"siteMetadata":{"domain":"https://www.docunext.com"}},"markdownRemark":{"html":"<p>After some initial excitement <a href=\"http://www.docunext.com/\">learning about DataMapper</a>, I became concerned that it might not be all it that I thought it was.</p>\n<p>Thankfully, it is!</p>\n<p>I was concerned about the associations capability. The documentation sounded great, but got a little fuzzy on me.</p>\n<p>I finally figured it out, and here's a quick and simple explanation of what I was concerned about. This should be an interesting example as it also involves single table inheritance:</p>\n<pre class=\"sh_ruby\">\nclass Entry\n  include DataMapper::Resource\n  property :id,Serial\n  property :memorandum,String\n  property :status,Integer\n  property :fiscal_period_id,Integer\n  has n, :credits\n  has n, :debits\nend\nclass Amount\n  include DataMapper::Resource\n  property :id,Serial\n  property :entry_id,Integer\n  property :type,Discriminator\n  property :amount,String\n  property :account_id,Integer\n  property :memorandum,String\n  belongs_to :entry\n  belongs_to :account\nend\nclass Credit &lt; Amount; end\nclass Debit &lt; Amount; end\n</pre>\n<p>Can you guess what type of data model this is? That's right - a double entry accounting system!</p>\n<p>Entries and credit and debit amounts are bound by foreign key constraints. Inasmuch, they are often grouped into result sets.</p>\n<p>The DataMapper docs clearly explain how to get the entries, like this:</p>\n<pre class=\"sh_ruby\">\nget '/entries' do\n    @myitems = Entry.all()\n    erb :entry_list\nend\n</pre>\n<p>But how can I get the credits and debits as well? It took a minute to figure it out, but I don't have to do anything at all. DataMapper does it for me. Impressive!</p>\n<p>To be more specific, I'll include this erb template, which is accesses the @myitems object, and what an object it turns out to be!</p>\n<pre>\n&lt;div class=\"accounts\"&gt;\n&lt;ul&gt;\n&lt;% @myitems.each do | item | %&gt;\n&lt;li&gt;Entries: &lt;%= item.id %&gt;,&lt;%= item.memorandum %&gt;\n&lt;br /&gt;&lt;% item.credits.each do | credit | %&gt;\nCredits: &lt;%= credit.id %&gt;,&lt;%= credit.amount %&gt;&lt;br/&gt;\n&lt;% end %&gt;\n&lt;br /&gt;&lt;% item.debits.each do | debit | %&gt;\nDebits: &lt;%= debit.id %&gt;,&lt;%= debit.amount %&gt;&lt;br/&gt;\n&lt;% end %&gt;\n&lt;/li&gt;\n&lt;% end %&gt;\n&lt;/ul&gt;\n&lt;/div&gt;\n</pre>\n<p>See what happens? I iterate through the entries, and on each entry, I'm able to access the associated data objects. <em>C'est incroilable!</em></p>\n<p>I'm not too crazy about erb templates, and I think that's one of the reasons why I had such a hard time figuring out the way DataMapper associations work.</p>\n<p>Wait! I'm not done yet. Another question I had involved how to create entry rows and associated amount rows.</p>\n<pre class=\"sh_ruby\">\npost '/new/entry' do\n    @entry = Entry.new(:memorandum => params[:entry_name])\n    @entry.save\n    @credit = @entry.credits.create(:amount => '5.00')\n    @debit = @entry.debits.create(:amount => '2.00')\n    @debit = @entry.debits.create(:amount => '3.00')\n    redirect '/entries'\nend\n</pre>\n<p>There is no error checking going on there, and the entry amounts are hard-coded, but it was enough for me to learn how DataMapper associations assist with the creation of data.</p>\n<p>NOTE: This code is from a Sinatra app I'm working on, hence the:</p>\n<pre class=\"sh_ruby\">\npost '/new/entry' do\n</pre>\n<p>syntax.</p>","fields":{"slug":"/2009/11/ruby-datamapper-associations/"},"frontmatter":{"title":"Ruby DataMapper Associations","date":"November 23rd, 2009","tags":"datamapper,orm,ruby,sinatra"}}},"pageContext":{"slug":"/2009/11/ruby-datamapper-associations/"}},
    "staticQueryHashes": ["3159585216","758480095"]}