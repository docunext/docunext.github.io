{"componentChunkName":"component---src-templates-blog-post-js","path":"/2009/12/circular-processing-with-xsl/","result":{"data":{"site":{"siteMetadata":{"domain":"https://www.docunext.com"}},"markdownRemark":{"html":"<p>The idea is to feed the output of a stylesheet back into itself, but how can the process be managed, not infinite?</p>\n<p>Andrew Welch suggests:</p>\n<blockquote>\nYou can do all the transformations in your pipeline in one stylesheet by\nperforming transformations within variables, with each variable\noperating on the previous one.\n<p>So, as top-level variables you could have:</p>\n<p>&#x3C;xsl:variable name=\"firstVar-rtf\"></p>\n<p>  &#x3C;xsl:apply-templates/></p>\n<p>&#x3C;/xsl:variable></p>\n<p>&#x3C;xsl:variable name=\"firstVar\" select=\"exsl:node-set($firstVar-rtf)\"/></p>\n<p>&#x3C;xsl:variable name=\"secondVar-rtf\"></p>\n<p>  &#x3C;xsl:for-each select=\"$firstVar\"></p>\n<pre><code>&#x26;lt;xsl:apply-templates/>\n</code></pre>\n<p>  &#x3C;/xsl:for-each></p>\n<p>&#x3C;/xsl:variable></p>\n<p>&#x3C;xsl:variable name=\"secondVar\" select=\"exsl:nodet-set($secondVar-rtf)\"/></p>\n<p>Here $firstVar operates on the source xml, and $secondVar works on the\n'result' of the apply-templates in $firstVar.</p>\n<p>The final link in the chain is of course:</p>\n<p>&#x3C;xsl:template match=\"/\"></p>\n<p>  &#x3C;xsl:for-each select=\"$lastVar\"></p>\n<pre><code>&#x26;lt;xsl:apply-templates/>\n</code></pre>\n<p>  &#x3C;/xsl:for-each></p>\n<p>&#x3C;/xsl:template></p>\n<p>All you need to do is separate out your problem into logical steps and\nperform each one in a varaible.</p>\n<p>I do this a lot when xslt 1.0 struggles to do a task in one go, such as\nfinding the average of two percentages written as 45% and 55%.</p>\n<p>The first variable would translate() the '%' away, the second variable\nwould find the average.</p>\n</blockquote>\n<p>Dimitre notes:</p>\n<blockquote>\nThis will select just the root node (/) of the temporary tree contained in\n$firstVar\n<p>Must be:</p>\n<pre><code>&#x26;lt;xsl:for-each select=\"$firstVar/node()\">\n</code></pre>\n<blockquote>\n<pre><code>&#x26;lt;xsl:apply-templates/>\n</code></pre>\n</blockquote>\n<blockquote>\n<p>  &#x3C;/xsl:for-each></p>\n</blockquote>\n<blockquote>\n<p>&#x3C;/xsl:variable></p>\n</blockquote>\n<blockquote>\n<p>&#x3C;xsl:variable name=\"secondVar\" select=\"exsl:nodet-set($secondVar-rtf)\"/></p>\n</blockquote>\n<blockquote>\n<p>Here $firstVar operates on the source xml, and $secondVar works on the</p>\n</blockquote>\n<blockquote>\n<p>'result' of the apply-templates in $firstVar.</p>\n</blockquote>\n<blockquote>\n</blockquote>\n<blockquote>\n<p>The final link in the chain is of course:</p>\n</blockquote>\n<blockquote>\n</blockquote>\n<blockquote>\n<p>&#x3C;xsl:template match=\"/\"></p>\n</blockquote>\n<blockquote>\n<p>  &#x3C;xsl:for-each select=\"$lastVar\"></p>\n</blockquote>\n<p>The same problem:</p>\n<p>Must be:</p>\n<pre><code>&#x26;lt;xsl:for-each select=\"$lastVar/node()\">\n</code></pre>\n<p>Dimitre Novatchev.</p>\n</blockquote>\n<p>I'm busy trying to figure this out....</p>\n<ul>\n<li><a href=\"http://www.biglist.com/lists/xsl-list/archives/200401/msg00044.html\">http://www.biglist.com/lists/xsl-list/archives/200401/msg00044.html</a></li>\n</ul>\n<p>Didn't do what I wanted it to, but I did learn something.</p>\n<pre>\n&lt;xsl:variable name=\"firstVar-rtf\">\n  First\n  &lt;xsl:apply-templates />\n&lt;/xsl:variable>\n&lt;xsl:variable name=\"firstVar\" select=\"exsl:node-set($firstVar-rtf)\"/>\n\n&lt;xsl:variable name=\"secVar-rtf\">\nSecond\n  &lt;xsl:for-each select=\"$firstVar/node()\">\n    &lt;xsl:copy-of select=\".\"/>\n    &lt;xsl:apply-templates />\n  &lt;/xsl:for-each>\n&lt;/xsl:variable>\n&lt;xsl:variable name=\"secVar\" select=\"exsl:node-set($secVar-rtf)\"/>\n\n&lt;xsl:variable name=\"tripVar-rtf\">\nThird\n  &lt;xsl:for-each select=\"$secVar/node()\">\n    &lt;xsl:copy-of select=\".\"/>\n    &lt;xsl:apply-templates />\n  &lt;/xsl:for-each>\n&lt;/xsl:variable>\n&lt;xsl:variable name=\"tripVar\" select=\"exsl:node-set($tripVar-rtf)\"/>\n\n&lt;xsl:template match=\"/\">\n&lt;div>\n  &lt;xsl:for-each select=\"$tripVar/node()\">\n\n    &lt;xsl:copy-of select=\".\"/>\n    &lt;xsl:if test=\"name()='h2'\">\n    skdlj\n    &lt;/xsl:if>\n\n    lakjdfkj\n  &lt;/xsl:for-each>\n  &lt;/div>\n&lt;/xsl:template>\n</pre>","fields":{"slug":"/2009/12/circular-processing-with-xsl/"},"frontmatter":{"title":"Circular Processing with XSL","date":"December 9th, 2009","tags":"xsl"}}},"pageContext":{"slug":"/2009/12/circular-processing-with-xsl/"}},"staticQueryHashes":["3159585216","3388129809"]}