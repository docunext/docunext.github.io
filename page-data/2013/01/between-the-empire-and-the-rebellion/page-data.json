{"componentChunkName":"component---src-templates-blog-post-js","path":"/2013/01/between-the-empire-and-the-rebellion/","result":{"data":{"markdownRemark":{"html":"<p>I just read <a href=\"http://tech.t9i.in/2013/01/why-program-in-go/\">Why I Program in Go</a> by Tahir Hashmi and really enjoyed it.\nIt traces his path through Python, PHP, Java, C++ and now to Go, and\nsome of his commentary echoed my own past (though my experience with Ruby sounds\nlike his experience with C++). My primary languages are PHP, Ruby, and\nJavascript.  I'm on the verge of diving into Go based on a single premise:\n<strong>static-linked binaries</strong>.\nI like single-file static binary web apps because of my dual-experience as\nsysadmin and developer. It is difficult to both build and maintain custom web\napps; the tasks are often delegated to separate people or teams with great\nsuccess. Doing both inspires and liberates me but the cost of maintaining\ndependencies spawned by that same liberating inspiration is crushing. Debian\nhandles dependencies successfully but I did not find their strategy applicable\nto custom web app dependencies. It is perfect for the underlying system, but\nbut not for me as an individual developer leveraging a wide range of external\nresources.\nI've used Ruby's bundler tool with moderate results; it takes a hybrid approach\nby dynamically bundling all dependencies along with each deployment resulting\nin what seems like a static deployment. But the dependencies are still there;\nthey can still fail and they are not shared ^1. As such it worsens what many\ndislike about Ruby: its performance and memory consumption, resulting in\na different type of fragility where a creation can collapse under its own\nweight.</p>\n<p>I've partly avoided the issue of dependencies by switching most of my personal\nweb apps (blogs) to static HTML files with the dynamic bits powered via\nJavascript. I like that strategy, but its new for me and I expect it to evolve,\nor maybe, devolve, into\nsomething similar to the cgi-bin isolation from days past. I can definitely say\nthat the reliability factor of static HTML files has been a serious relief. If\nI try out Go and find a similar relief when deploying a full application I will\nbe greatly satisfied. Keeping web applications up-and-running 24/7/365 is a lot\nof work, but it doesn't have to be that way. We've put up with it for\nso long because its an interesting challenge. But remember: the future <em>always</em>\nholds interesting challenges for us. Its time to move on.</p>\n<p>I don't want to waste time chasing a rabbit, so as Tahir mentions, the folks\nbehind Go should make it a worthwhile venture. But there are lots of accomplished\npeople out there who are doing insubstantial work. Prior feats of those involved\nare not enough for me and brings me back to the salient factor: <strong>static-linked\nbinaries</strong>. I could build a small project, deploy it, and monitor its\nreliability. It would need to serve enough purpose to stand the test of time,\nand not fade away; a \"middle ground\", if you will.\nWeb applications massively thrive or quickly fade, and I bet there is\nroom for something in-between. I would find comfort there and it would\nencourage diversity and free expression. Software doesn't have to be either the\nempire or the rebellion.</p>\n<p>I want to express myself with the best tools available, but not at the\nexpense of my expressions. I have much to contribute, and little time to do it.\nMore than express myself, I want to build great things. I've chosen software to\nhelp me accomplish that. Sophisticated tools are prone to malfunction if they\nare not routinely maintained and I've found that many of my creations do not\nstand the test of time, and I want them to. If Go can bring more persistence to\nmy creations, it will be useful to me. This is my rationale for taking\nthe time to build something in Go and observe its wherewithal over the\nensuing years.</p>\n<h5>Update January 21, 2013</h5>\n<p>I built a simple CGI binary in Golang this weekend and the experience was highly\npositive and I'm planning to delve further into it soon. For now I'll briefly\nshare my notes:</p>\n<ul>\n<li>Building go for 386 architecture was fun, I develop on AMD64 but deploy to 386</li>\n<li>Go's dependency management system is crazy good; the compiler tool-chain\nincludes support for package distribution like rubygems or the cheese shop</li>\n<li>As new as Go is, there are an impressive number of library bindings</li>\n<li>Go binaries are fast, even when run over CGI</li>\n</ul>\n<p>My next steps:</p>\n<ol>\n<li>Create a long running Go app server via an HTTP or FastCGI server </li>\n<li>Monitor its memory usage</li>\n</ol>\n<p>^1: Passenger and the Ruby Enterprise Edition helped out a lot with Ruby and\nRuby on Rails memory management and performance by sharing dependencies across\nmultiple web apps and forked processes. Bundler inhibits those optimizations by\nnot sharing any dependencies.</p>","frontmatter":{"title":"Between the Empire and the Rebellion","date":"January 19th, 2013"}}},"pageContext":{"slug":"/2013/01/between-the-empire-and-the-rebellion/"}}}