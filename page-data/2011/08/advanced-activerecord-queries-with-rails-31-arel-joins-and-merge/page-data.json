{"componentChunkName":"component---src-templates-blog-post-js","path":"/2011/08/advanced-activerecord-queries-with-rails-31-arel-joins-and-merge/","result":{"data":{"site":{"siteMetadata":{"domain":"https://www.docunext.com"}},"markdownRemark":{"html":"<p>I've been exploring <strong>Rails 3.1</strong> for a couple weeks now and last night I focused on advanced queries with Active Record, utilizing some new scoping features thanks to Arel.</p>\n<p>Note: I'm not fully versed in <strong>Arel</strong> as of yet, but as far as I understand, it's related to what I figured out last night.</p>\n<p>I've written about <a href=\"http://www.docunext.com/2011/03/rails-3-activerecord-scope-and-chainability-helpers/\">scopes in Rails 3</a> before, but nowadays I'm keener on class methods, like this one:</p>\n<pre class=\"sh_ruby\">\n1 class Entry < ActiveRecord::Base\n...\n 45   class << self\n 46     def before_date(date)\n 47       where([\"date <= ?\", date])\n 48     end\n 49   end\n...\n 92 end\n</pre>\n<p>In the above example, the before_date method will not be called until it is used, and it will change the SQL generated for the database query.</p>\n<p>How about a more advanced example? Here's a sweet thing:</p>\n<pre class=\"sh_ruby\">\n  1 class Transaction < Record\n  2\n  3   validates :amount_in_cents,\n  4             :presence => true,\n  5             :numericality => true\n  6\n  7   class << self\n  8     def before_date(date)\n  9       joins(:entry).merge(Entry.before_date(date))\n 10     end\n 11   end\n 12\n 13   def amount_in_cents=(amount_in_cents)\n 14     write_attribute(:amount_in_cents, amount_in_cents.to_f * 100)\n 15   end\n 16\n 17   def amount\n 18     amount_in_cents * 0.01\n 19   end\n 20 end\n~\n</pre>\n<p>In this case, it results in some awesome SQL:</p>\n<pre class=\"sh_terminal\">\n>> @expense.entries.before_date(Date.today + 1.day).to_sql\n=> \"SELECT \\\"entries\\\".* FROM \\\"entries\\\" INNER JOIN \\\"transactions\\\" ON \\\"entries\\\".\\\"id\\\" = \\\"transactions\\\".\\\"entry_id\\\" WHERE \\\"transactions\\\".\\\"account_id\\\" = 1 AND (date <= '2011-08-19')\"\n</pre>\n<p>Nice, huh?</p>\n<p>Supposedly, this syntax:</p>\n<pre class=\"sh_ruby\">\njoins(:entry).merge(Entry.before_date(date))\n</pre>\n<p>is equivalent to:</p>\n<pre class=\"sh_ruby\">\njoins(:entry) & Entry.before_date(date)\n</pre>\n<p>But I have found that to be entirely false and not true. For the above referenced scenario, I found the latter syntax to result in two SQL queries instead of a join, like so:</p>\n<pre class=\"sh_ruby\">\n>> @expense.transactions.joins(:entry) & (Entry.before_date(Date.tomorrow))\n  Transaction Load (0.6ms)  SELECT \"transactions\".* FROM \"transactions\" INNER JOIN \"entries\" ON \"entries\".\"id\" = \"transactions\".\"entry_id\" WHERE \"transactions\".\"type\" IN ('Transaction') AND \"transactions\".\"account_id\" = 16\n  Entry Load (0.5ms)  SELECT \"entries\".* FROM \"entries\" WHERE (date <= '2011-08-21')\n</pre>\n<p>Thanks:</p>\n<ul>\n<li><a href=\"http://asciicasts.com/episodes/215-advanced-queries-in-rails-3\">http://asciicasts.com/episodes/215-advanced-queries-in-rails-3</a></li>\n</ul>","fields":{"slug":"/2011/08/advanced-activerecord-queries-with-rails-31-arel-joins-and-merge/"},"frontmatter":{"title":"Advanced ActiveRecord Queries with Rails 3.1 Arel joins and merge","date":"August 18th, 2011","tags":"activerecord,\"ruby on rails 3\""}}},"pageContext":{"slug":"/2011/08/advanced-activerecord-queries-with-rails-31-arel-joins-and-merge/"}}}