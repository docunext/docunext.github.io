{"componentChunkName":"component---src-templates-blog-post-js","path":"/2011/05/metaprogramming-with-ruby/","result":{"data":{"site":{"siteMetadata":{"domain":"https://www.docunext.com"}},"markdownRemark":{"html":"<p>There are many reasons why I love working with Ruby, such as its consistency, its use of natural language, its clean object-oriented paradigm, but one aspect of it is that stands out above the rest: its metaprogramming capabilities.</p>\n<h4>What is \"Metaprogramming\"?</h4>\n<p>Metaprogramming is the practice of writing code that generates more code, and then running that code in the same process.</p>\n<p>Seen from another angle, it is the practice of writing code that modifies or adds to itself as it runs. As such, in my humble opinion, its a heck of a lot easier to do with an scripting / interpreted language like Ruby than a compiled language like C.</p>\n<p>Metaprogramming is also related to domain specific languages. In the case of Ruby, Rake and Sinatra are domain specific languages.</p>\n<h4>Examples of Metaprogramming</h4>\n<p>There are many different paths to and styles of metaprogramming in other languages; in Ruby, there are built-in hooks to help software engineers build software which will eventually make themselves obsolete! (Just a little humor there for you... or not?) The hooks are method_missing and define_method.</p>\n<p>On their own, they are quite useful tools. Together, they are a powerful combo that are filled me with awe of Ruby - we'll touch on that later. First, what are they and what do they do. (Side note: \"Who is your daddy,  and what does he do?\" - Anyone? Anyone?)</p>\n<h4>method_missing</h4>\n<p>If you've ever had a typo in a method call, you've likely encountered method_missing. It is called when a non-existent method is called, and its included as part of Ruby's Kernel class<span class=\"sup\">1</span>.</p>\n<p>The general practice is to override method_missing, and do something besides raising an exception. So let's get to an example, shall we?</p>\n<pre class=\"sh_ruby\">\nclass Foo\n  def method_missing(m, *args, &block)\n    if m.to_s.include? 'bar'\n      puts \"SNAFU\"\n    else\n      super\n    end\n  end\nend\nyo = Foo.new\nyo.foobar\nyo.snafu\n</pre>\n<p>I've employed some standard best-practices with this example, so it isn't the simplest case, but fear not oh loyal reader, I shall explain what's going down.</p>\n<p>First off, method_missing can take three arguments, and I've included them here. It requires the first one, which is the name of the missing method that is getting called. The next two are the arguments and / or the block that are getting passed to the method.</p>\n<p>After that, there is a test to check whether the method name includes \"bar\". Why? This is a technique to ensure that non-existent methods that really should not exist are not handled. Why? So that bugs like typos can be identified. If you take a moment to ponder, you might agree that's its generally not a good idea to try and generate code for every potential method name in existence!</p>\n<p>If the calling method's name does include the string \"bar\", we'll put \"SNAFU\", if not, we let the standard method_missing method handle it (and raise an exception). If I run this code, that's exactly what will happen:</p>\n<pre class=\"sh_terminal\">\n?> yo = Foo.new\n=> #<Foo:0xb74836c4>\n>> yo.foobar\nSNAFU\n=> nil\n>> yo.snafu\nNoMethodError: undefined method `snafu' for #<Foo:0xb74836c4>\n\tfrom (irb):7:in `method_missing'\n\tfrom (irb):15\n</pre>\n<p>Yay! We're already metaprogramming. What happened? When yo called foobar, yo could not find a method with its name, so its version of method_missing created a temporary one on the fly. Cool, huh?</p>\n<h4>define_method</h4>\n<p>In my humble opinion, define_method is where things really get exciting, because when combined with method_missing, it is possible to start really building code during runtime.</p>\n<p>The define_method method is found in the <a href=\"http://ruby-doc.org/core/classes/Module.html#M000497\">Module class</a>. It is private class method, so it is called on its parent object, not on instances.</p>\n<p>First let's take a look at what define_method can do. Examine these two classes:</p>\n<pre class=\"sh_ruby\">\nclass Foo\n  def snafu\n    puts \"hi\"\n  end\nend\nclass Bar\n  define_method(:snafu) do\n    puts \"hi\"\n  end\nend\n</pre>\n<p>In essence, they are identical. So why would we ever want to use something like define_method? Its often used with arrays, like this:</p>\n<pre class=\"sh_ruby\">\nmodule Stuff\n  MYKEYS = ['date','betterdate']\n  MYHASH = {\n          't1' => {'date' => '2000', 'betterdate' => '2000', 'dynamicdate' => '2000' },\n          't2' => Hash.new('2011')\n        }\nend\nclass Test\n  include Stuff\n  MYKEYS.each do |k|\n    define_method(k.to_sym) do |myid|\n      MYHASH[myid][k]\n    end\n  end\nend\n</pre>\n<p>In that example, we're creating methods to access values from a hash. This example is futile; hopefully it illustrates how define_method could be used on its own. Handy, right? Not really earth shattering though... what gives? Its limited by the fact that it is a private class method that creates class methods when its class is defined. In other words, it cannot be called directly during runtime making it a heck of a lot less dynamic than method_missing. Can you tell the difference? Good! Now let's talk about the magical combo.</p>\n<h4>A Match Made of Rubies: method_missing and define_method</h4>\n<p>I employ no hyperbole - this is where the magic happens.</p>\n<p>Remember that the problem with method_missing is that it is a private class method, and can't be directly called from an instance at runtime. Is there another way??? <strong>Yes!</strong> Here comes method_missing to the rescue.</p>\n<p>I'll jump right into an example:</p>\n<pre class=\"sh_ruby\">\n  def method_missing(m, *args, &block)\n    if ALLKEYS.include?(m.to_s)\n      # Yes, smarter key\n      self.class.send(:define_method, m) do\n        MYHASH[name][m.to_s]\n      end\n      self.send(m)\n    else\n      super\n    end\n  end\n</pre>\n<p>Like the first example of method_missing, I've again employed some standard best-practices to use with method_missing, like the string inclusion check, and the alternate push to super, the rest is much different - what's going on with all the sends?</p>\n<p>With method_missing, we can tell an instance to ask its parent class to call upon one of its class methods, specifically define_method: <tt>self.class.send(:define_method, m) do</tt>. In doing so, we can pass it the non-existent method's name, and whatever the non-existent method is passed. After that, we can actually call the method as an instance method. Sufferin' succotash! That is inconceivable!</p>\n<p>Savvy readers might be wondering:</p>\n<blockquote class=\"svxlb\"><pre>\nWhat's the advantage of doing it this way as opposed to simply using method_missing by itself?\n</pre></blockquote>\n<p>There is a very good reason for using define_method inside of method_missing:\nperformance. Let me elaborate.</p>\n<p>Software engineering often involves patterns that slightly or substantially\ndiffer from one another, and sometimes those patterns are programmatic. As such,\nsoftware engineers can write algorithms to identify and specify those patterns,\nsaving themselves immeasurable time having to manually write code that consists\nof mostly repetitive logic that slightly differs here and there.</p>\n<p>The problem with employing that method at compile time (or in the case of Ruby,\nupon instantiation), is that it can take a long time to iterate through all the\npossible pattern changes and generate code to support it - an issue exacerbated\nby the likelihood that not all of the pattern differences are significant and\nwill never be used. So why not create a method to catch those patterns during\nruntime and define real methods to handle them if and when they next needed?\nI can't think of a reason, so let's do so. This practice is often referred to as\nlazy loading, and in my humble opinion, its a <em>very</em> cool way to work.</p>\n<p>Other engineers agree - ORM tools like ActiveRecord and DataMapper use lazy\nloading to dynamically generate methods for object properties based upon\ncharacteristics of the data sets. If they created all those methods up front, it\nwould take a much longer for Ruby applications to use them, and if they only\nused method_missing, they would not be optimizing when they could.</p>\n<p>I'd love to hear your thoughts about Metaprogramming with Ruby, or this post.\nSee any typos or areas of improvement? Use the comment form below to sound off.</p>\n<h4>See Also</h4>\n<ul>\n<li><a href=\"http://www.docunext.com//ruby-metaprogramming/\">Metaprogramming with Ruby</a></li>\n</ul>\n<h4>Footnotes</h4>\n<ul>\n<li><span class=\"sup\">1</span> - While I was checking on that, I noticed that it is not included in the <a href=\"http://www.ruby-doc.org/core/classes/Kernel.html\">Ruby 1.9.2 API documentation for the Kernel class</a>, though it is of course included in <a href=\"http://www.ruby-doc.org/core-1.8.7/classes/Kernel.html#M001069\">1.8.7</a>. Does anyone know what's up with that?</li>\n</ul>","fields":{"slug":"/2011/05/metaprogramming-with-ruby/"},"frontmatter":{"title":"Metaprogramming with Ruby method missing and define method","date":"May 21st, 2011","tags":"ruby"}}},"pageContext":{"slug":"/2011/05/metaprogramming-with-ruby/"}},"staticQueryHashes":["3159585216","758480095"]}