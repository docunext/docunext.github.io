{"componentChunkName":"component---src-templates-blog-post-js","path":"/2010/01/dynamic-single-table-inheritance-datamapper/","result":{"data":{"site":{"siteMetadata":{"domain":"https://www.docunext.com"}},"markdownRemark":{"html":"<p>I'm tinkering with a new datamodel for Regdel which relies heavily upon datamapper's single-table inheritance capabilities.</p>\n<p>However, I'm not sure how much work would be required to manage the datamapper classes. Its a concern, and I've considered an alternative of dynamically generating the classes.</p>\n<p>It is fairly common to find Ruby code that generates more code, and then runs it: <strong>\"eval\"</strong>.</p>\n<div>\nWhat's extra nice about Ruby's ability to do such a thing is that has a class_eval function.\n</div>\n<p>That makes it possible to do cool stuff like this:</p>\n<pre class=\"sh_ruby\">\n# This will only work for trees with two generations\ninh = \"\"\n{\"Bank\" => \"Asset\", \"Trust\" => \"Bank\", \"Operating\" => \"Bank\"}.each_pair { |k,v|\n    acc = Extlib::Inflection.pluralize(k).downcase\n    Xact.class_eval(\"has n, :\"+acc)\n    eval \"defined?(#{v})\"\n    unless eval(\"defined?(#{v})\") == 'constant'\n      inh = inh + \"class #{k} < #{v}; end\\n\"\n    else\n      eval(\"class #{k} < #{v}; end\\n\")\n    end\n}\neval(inh)\n</pre>","fields":{"slug":"/2010/01/dynamic-single-table-inheritance-datamapper/"},"frontmatter":{"title":"Dynamic Single Table Inheritance Datamapper","date":"January 14th, 2010","tags":"datamapper,ruby"}}},"pageContext":{"slug":"/2010/01/dynamic-single-table-inheritance-datamapper/"}},"staticQueryHashes":["3159585216","3388129809"]}