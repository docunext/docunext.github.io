{"data":{"markdownRemark":{"html":"<p>I've finally got Basic HTTP authentication working in a manner that is\nrelatively secure, user-friendly, and has a logout.</p>\n<h3>Description</h3>\n<p>This solution uses jQuery to send credentials supplied in an HTML for as a\nBasic Authorization header to NGINX using ajax. It doesn't look like HTTP auth\nfrom the user perspective - it doesn't even revert back to it if the auth fails.</p>\n<p>It is secure because there are actually two ajax requests; one to get a random\nsalt from the server (updating the db in the process), and another to send the\nauthorization header. The first request is to prevent replay attacks. Before the\nsecond ajax request, the salt and the password are hashed so that the password\nis never sent in the clear.</p>\n<h3>Ingredients</h3>\n<ol>\n<li>Nginx with the lua module</li>\n<li>libpam-pgsql library </li>\n<li>Postgres with the pgcrypto extension</li>\n<li>jQuery</li>\n<li>Concepts and js encryption code from <a href=\"http://pajhome.org.uk/crypt/md5/index.html\">Paj</a></li>\n<li>Concepts from <a href=\"http://www.peej.co.uk/articles/http-auth-with-html-forms.html\">Peej</a> about HTTP Authentication</li>\n</ol>\n<h3>Configuration and Code Examples</h3>\n<h3>Nginx</h3>\n<p>Nginx is capable of overriding the status of an error, in this case, the 401\nstatus code gets changed to 403, not authorized, to avoid having the browser\nprompt the user for their credentials again.</p>\n<pre><code>location = /cgi-bin/authenticate.cgi {\n  auth_pam \"Login\";\n  default_type text/plain;\n  error_page 401 =403 @hmm;\n  echo '';\n}\nlocation @hmm {\n  echo '';\n}\nlocation /cgi-bin/salt.cgi {\n  access_log off;\n  content_by_lua_file '/usr/local/lib/salt.lua';\n}\n</code></pre>\n<h3>Lua</h3>\n<p>The <tt>/usr/local/lib/salt.lua</tt> file:</p>\n<pre><code>luasql = require \"luasql.postgres\"\njson = require \"json\"\nmysalt = math.random(1000,10000)..\"h\"\nenvv = assert (luasql.postgres())\ncon = assert (envv:connect(\"dbname\", \"dbuser\", \"dbpass\", \"127.0.0.1\", 5432))\nres = assert(con:execute(\"UPDATE account SET salt = '\"..mysalt..\"' WHERE email = '\"..ngx.req.get_uri_args()[\"email\"]..\"' OR  username = '\"..ngx.req.get_uri_args()[\"email\"]..\"'\"))\ncon:close()\nenvv:close()\nngx.header.content_type = \"application/json\"\nngx.say(json.encode( {salt=mysalt} ))\n</code></pre>\n<h3>jQuery</h3>\n<pre><code>\n// courtest of stack overflow...\nfunction make_base_auth(user, password) {\n  var tok = user + ':' + password;\n  var hash = btoa(tok);\n  return \"Basic \" + hash;\n}\n\n$('#userLogin').submit(function(e) {\n  e.preventDefault();\n\n  var username = $('#inputEmail').val();\n\n  $.ajax({\n    url      : '/cgi-bin/salt.cgi',\n    type     : 'GET',\n    async    : false,\n    data     : { email: username },\n    dataType : 'json' \n  }).done(function(json) {\n\n    var salt = json[\"salt\"];\n    var hash = hex_sha256($('#inputPassword').val());\n    var password = hex_hmac_sha256(salt, hash);\n\n    $.ajax({\n      url      : '/cgi-bin/authenticate.cgi',\n      type     : 'GET',\n      headers  : { Authorization: make_base_auth(username, password) },\n      success  : function(){\n        setTimeout(function() { window.location = '/'; }, 2000);\n      },\n      error    : function(){ console.log('error'); }\n    });\n\n  });\n\n});\n\n$(\".logout\").live('click', function(e) {\n  e.preventDefault();\n  \n  $.ajax({\n    url      : '/cgi-bin/authenticate.cgi',\n    type     : 'GET',\n    username : 'anony',\n    password : 'mouse'\n  });\n});\n</code></pre>\n<h3>Postgres and libpam</h3>\n<p>Part of the <tt>/etc/pam_pgsql.conf</tt> file:</p>\n<pre><code>\npw_type=clear\nauth_query = select encode(hmac(password, salt, 'sha256'),'hex') as password \\\n  from account where (username = %u OR email = %u) and email_confirmed IS NOT FALSE\n</code></pre>\n<p>The password is stored in the database as a sha256 hash, but I set it as clear\nin the conf file so that I can do the hmac in the auth query.</p>\n<h3>Feedback</h3>\n<p>Security is best when scrutinized. I'd welcome your feedback, questions, or\nconcerns.</p>\n<h3>Update Mar 27, 2013</h3>\n<p>I'm not using this solution anymore, but it was fun to explore - doing so taught\nme a lot about security. I am using something similar now:</p>\n<ul>\n<li>No HTTP authentication, I've switch to using Rails for authentication using\nbcrypt to store the password</li>\n<li>The Rails app creates a PKI key, based on <a href=\"http://iamjosh.wordpress.com/2008/03/18/encrypting-login-password-without-ssl-in-ruby-on-rails/\">these concepts from Josh</a>,\nthe PEM key of which is stored in the Rails encrypted and signed cookie</li>\n<li>The login form includes the PKI modulus and initialization vector</li>\n<li>Javascript from <a href=\"http://www-cs-students.stanford.edu/~tjw/jsbn/\">TWJ</a> encrypts the raw password with the public key</li>\n<li>Rails uses the pem key stored in the cookie to decrypt the password, which it\nthen uses to authenticate the user</li>\n</ul>\n<p>I probably <em>will</em> buy an SSL certificate at some point, but I'd rather not.\nI really don't see them as being much more secure. There are many websites where\nthe only truly private data that gets transferred or not stored in plaintext on\nthe server is the password.</p>","frontmatter":{"title":"jQuery Basic HTTP Authentication","date":"January 30th, 2013"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2013/2013-01-30-jquery-basic-http-authentication/"}}