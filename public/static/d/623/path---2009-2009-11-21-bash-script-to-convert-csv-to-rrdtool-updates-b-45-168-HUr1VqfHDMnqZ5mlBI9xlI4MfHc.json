{"data":{"markdownRemark":{"html":"<p>Before I learned how to use RRDTool, I stored some time lapse data in a simple CSV file.</p>\n<p>When I learned how to use RRDTool, I had to convert the old CSV data to the rrd file.</p>\n<p>To do so, I used this bash script:</p>\n<pre class=\"sh_sh\">\nwhile read LINE; do\n    ts=$(date -d \"`echo $LINE | awk '{print $1, $2, $3, $4, $5, $6 }' | sed s/,//`\" +%s)\n+%s | sed -r s/$/:/\n    temp=`echo \"$LINE\" | awk '{print $7}'`\n    echo \"rrdtool update temps_take_2.rrd ${ts}:${temp}\"\ndone < temps.csv\n</pre>\n<p>I first changed the human-readable date-time to a UNIX timestamp (number of seconds since January 1, 1970) and set the variable \"ts\" to its value.</p>\n<p>Then I set another variable with the temperature value, and assembled a command to update the rrd database with rrdtool.</p>\n<p>This bash script doesn't do it all by any means. I streamed the old CSV data into it with cat and a pipe (STDIN), and then redirected the output (STDOUT) to another file I named \"commands.sh\". I then executed the commands.sh file with \"sh commands.sh\".</p>\n<p>Most of the above explanation is obvious to some, but I'm explaining what I did in extreme detail for those who may appreciate it, but also for my own understanding. I'm trying to gain a better understanding of UNIX philosophies, one of which is the idea of passing data streams through chains of filters (awk, sed, etc.) connected by pipes (stdin, stdout, file descriptors).</p>\n<p>I'm hoping to get a extend my understanding from pipes to forks soon! :-)</p>","frontmatter":{"title":"Bash Script to Convert CSV to RRDTool Updates"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2009/2009-11-21-bash-script-to-convert-csv-to-rrdtool-updates/"}}