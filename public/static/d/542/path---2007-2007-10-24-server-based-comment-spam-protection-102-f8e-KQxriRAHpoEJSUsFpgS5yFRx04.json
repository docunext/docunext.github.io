{"data":{"markdownRemark":{"html":"<a href=\"http://www.docunext.com/blog/2007/10/24/server-based-comment-spam-protection/\">\n<p>I've been thinking about how to protect Wordpress, Trac, and other \"community-style\" web applications against comment spam, so I figured I should write up an article about my thoughts here at Docunext.com.</p>\n<h3>Spam Karma 2</h3>\n<p>Spam Karma is useful for Wordpress, but it uses up a lot of server resources. It appears to be Wordpress only, too.</p>\n<h3>Spamassassin</h3>\n<p>Spamassassin works great for emails, but I can't figure out how to get it to work for Trac (or Wordpress for that matter). I found a perl client for connecting to spamd, but then I couldn't find the format information should be sent to the daemon.</p>\n<h3>dnsbl</h3>\n<p>There are some promising modules in the works for Apache which appear to connect directly with dnsbl servers, but they aren't mature enough for what I'm looking for. Most are still in alpha stage.</p>\n<h3>mod_rewrite?</h3>\n<p>mod_rewrite has a few features which could prove to be very helpful in defending against comment spam. One: RewriteMap, Two: [F] (forbidden). Here's a quick sample of how this might work:</p>\n<pre><Directory /var/www>\n\nRewriteMap badbots txt:bad_bots\n\nRewriteEngine On\n\nRewriteCond %{REQUEST_METHOD} POST\n\nRewriteCond ${badbots:%{REMOTE_ADDR}} 1\n\nRewriteRule . - [F]\n\nOptions ExecCGI FollowSymlinks\n\nAllow from all</Directory></pre>\n<p>The nice thing about this rewriterule is that it only targets POST requests. The problem is that it requires a file to reference with an ip address. This would be difficult to update on a regular basis, but not impossible. You could also use an external program such as a perl script to query a dnsbl, but I'm not sure if that works so well, especially if you have a whole bunch of scripts.</p>\n<p>Block List</p>\n<p>Pass List</p>\n<p>Another positive factor of the above access control is that it is simple, quick, effective, and could be used server-wide. It could easily be extended to support pass lists as well as authenticated bypasses. <b>Related:</b></p>\n<p><a href=\"http://www.spamcannibal.org/cannibal.cgi\">http://www.spamcannibal.org/cannibal.cgi</a></p>\n<p><a href=\"http://unknowngenius.com/blog/wordpress/spam-karma/\">http://unknowngenius.com/blog/wordpress/spam-karma/</a></p>\n<p><a href=\"http://spamassassin.apache.org/\">http://spamassassin.apache.org/</a><b>Link / Quote of the Day</b></p>\n<p><a href=\"http://kerneltrap.org/Linux/Compiler_Optimization_Bugs_and_World_Domination\">http://kerneltrap.org/Linux/Compiler<em>Optimization</em>Bugs<em>and</em>World_Domination</a></p>\n<blockquote>During the thread, Linus suggested that the optimization made by the compiler wasn't \"legal\", to which Alan Cox retorted, \"pedant: valid. Almost all optimizations are legal, nobody has yet written laws about compilers. Sorry but I'm forever fixing misuse of the word 'illegal' in printks, docs and the like and it gets annoying after a bit.\" Linus playfully responded, \"heh. When I'm ruler of the universe, it *will* be illegal. I'm just getting a bit ahead of myself.\" When asked how long until he expected to be ruler, Linus added, \"I'm working on it, I'm working on it. I'm just as frustrated as you are. It turns out to be a non-trivial problem.\"</blockquote>\n<h3>mod_defensible</h3>\n<p>UPDATE October 27, 2007: Found these promising modules: * <a href=\"http://julien.danjou.info/mod_defensible.html\">http://julien.danjou.info/mod<em>defensible.html</a>* &#x3C;a href=\"<a href=\"http://www.steve.org.uk/Software/mod\">http://www.steve.org.uk/Software/mod</a></em>ifier/index.html\"><a href=\"http://www.steve.org.uk/Software/mod_ifier/index.html\">http://www.steve.org.uk/Software/mod_ifier/index.html</a></a></p>\n<p>UPDATE October 28, 2007: So far mod<em>defensible is working nicely. I had to enter an alternate DNS resolver as described on the &#x3C;a href=\"<a href=\"http://julien.danjou.info/mod\">http://julien.danjou.info/mod</a></em>defensible.html\">mod<em>definsible hompage</a>. Otherwise the server would hang, probably unable to resolve the dnsbl. I'm really liking the idea of using mod</em>defensible as a first line of defense against comment spam for quick filtering.</p>\n<p>UPDATE October 30, 2007: I'm now trying out mod_defensible on a production server, it will be interesting to find out if the volume of spam caught by spam karma 2 decreases.</p>\n<p>UPDATE October 31, 2007: Over the night, mod<em>defensible was causing apache processes to never die, resulting in the maxclients directive getting reached and a denial of service (DoS). I've disabled mod</em>defensible and am emailing the author to ask if there is a timeout or something to alleviate this problem.</p>\n<p>I wrote to the author Julien and he responded back quickly (thanks!) saying he's aware of the issue, but doesn't have time to work on it at the moment. I'm no good at C, but if you are, please help! :-)</p>\n<p>Debugging now - I figured out that the Limit directive isn't in the scope of mod_defensible, so I'm also trying the location scope. Good, that seems to work better. To fend off the possibility of zombie processes, I think it's best to consider using a local dns server. But still that's not too good an idea in case the dns server crashes.</p>\n<p>Interesting, apache won't become a zombie process if udns isn't used and the dnsbl is invalid. Perhaps that is the way to go. The question is whether the same or a similar effect to that of <a href=\"http://www.corpit.ru/mjt/udns.html\">udns</a> can be achieved by setting the system's resolv.conf to use a caching dns resolver, like dnsmasq.</p>\n<p>Unfortunately the limit directive is a little different than the directory, location, and files directive, so I'm having to use mod_rewrite to achieve my goal. Here's what I've got going on:</p>\n<pre>\nRewriteEngine On\n\nRewriteCond %{REQUEST_METHOD} POST\n\nRewriteRule (.*) /__POST__$1 [PT]<Location /__POST__/>        DnsblUse On        #DnsblServers zen.spamhaus.org.        DnsblServers localhost.</Location>\n\nAlias /__POST__/ /var/www/</pre>\n<p>While I was in the source code for mod<em>defensible, I tried setting a timeout for udns, but what I tried didn't work. On line 356 of mod</em>defensible.c:</p>\n<pre>        if(poll(&pfd, 1, dns_timeouts(0, -1, 0) * 1000))</pre>\n<p>I changed the -1 to 4, but it resulted in the same behavior. What strikes me as odd is that the first parameter is a 0, but in the reference for udns it is ctx, which I <em>think</em> is a reference to the udns object. Maybe if I change the 0 to the reference used throughout the rest of the code, the timeout will work?</p>\n<pre>\nif(poll(&pfd, 1, dns_timeouts(&dns_defctx, 4, 0) * 1000))</pre>\n<p>By the way, to reproduce the timeout error, setup a non-existent dns resolver and feed it a non-existent dnsbl.</p>\n<pre>                DnsblUse On                DnsblNameserver 7.0.0.1                DnsblServers zeniy.spamhaus.org.                #DnsblServers localhost.</pre>\n<p>Nope, that didn't work either.</p>\n<p>I'm working my way through the mod_defensible code, and I've got a few ideas. I think that the modules should have the option of setting an environment variable as opposed to strictly sending a 403 and error message. To achieve that, I changed the hook near the end of the file to:</p>\n<pre>    ap_hook_fixups(check_dnsbl_access, NULL, NULL, APR_HOOK_MIDDLE);</pre>\n<p>That seems to work OK. In trying to come up with a way to timeout the udns lookup, I came up with a really chessy method to try out:</p>\n<pre>#ifdef HAVE_LIBUDNS    struct pollfd pfd;    struct udns_cb_data **data_array_elts;    int cheesy_timeout = 0;    pfd.fd = dns_sock(0);    pfd.events = POLLIN;    data_array_elts = (struct udns_cb_data **) data_array->elts;    /* While we have a queue active */    while(dns_active(&dns_defctx) && cheesy_timeout < 99) {        if(poll(&pfd, 1, dns_timeouts(0, -1, 0)) * 1000)            dns_ioevent(0, 0);        cheesy_timeout++;    }    dns_close(&dns_defctx);    /* Check if one of the DNSBL server has blacklisted */    for(i = 0; i < data_array->nelts; i++)        if(data_array_elts[i]->blacklist)        {                /*            r->status = 403;            generate_page(r, data_array_elts[i]->dnsbl);            */            apr_table_setn(r->subprocess_env, \"defensible\",\"defensible\");            return OK;        }#endif</pre>\n<p>This is a very poor method, and might not work without the other changes I made. Like not using the denial page, but instead setting an environment variable, which can then be used by other access controls to block, filter, or redirect various requests. Cool, huh?</p>\n<p>I've still got some major cleanup to do, but thanks to the great work by <a href=\"http://julien.danjou.info/mod_defensible.html\">Julien</a> on this, I was actually able to learn a ton about Apache modules, and maybe even make one a little better! :-)</p>\n<p>I just sent Julien this email:</p>\n<blockquote>\n<p>I actually did some stuff. :-)</p>\n<p>I changed the result of a dnsbl positive to set an environment variable \"defensible\". A better solution would have the env variable name set in the configuration file, but I don't really know what I'm doing. That way, the user can test for the env and handle it in a variety of ways, and even use a custom error file. To do this I had to change the hook to fixups.</p>\n<p>As for the timeout, I came up with a very cheesy solution: limiting the while loop to 150 iterations! I've set it as low as 9 and it was able to resolve without timing out, but I was using a local resolver. This should also be configurable, but I don't know how to do that yet. I tried a bunch of udns functions but couldn't get a handle on it. I just happened to have an Apache book handy so that's why I stuck to the Apache API.</p>\n<p>Obviously the timeout is not the best, but since I'm using this mainly to ward off comment spam, it isn't a big deal if there is a timeout. I may even just stick with the system dns resolver as I was also able to figure out a way to use the dnsbl for only POST requests.</p>\n<p>Thanks again, I'm curious to learn what you think of the patch. </blockquote></p>\n<p>And the patch: <textarea rows=\"14\" cols=\"60\"><pre>--- mod<em>defensible.c.orig\t2007-10-31 17:43:54.000000000 -0400+++ mod</em>defensible.c\t2007-10-31 17:45:04.000000000 -0400@@ -59,6 +59,7 @@ {     enum use<em>dnsbl</em>type use<em>dnsbl;     apr</em>array<em>header</em>t <em>dnsbl<em>servers;+    apr</em>table<em>t *features; #ifdef HAVE</em>LIBUDNS     char * nameserver; #endif@@ -179,18 +180,6 @@ } #endif-static void generate<em>page(request</em>rec *r, char * dnsbl)-{-    ap<em>set</em>content<em>type(r, \"text/html\"); -    ap</em>rputs(DOCTYPE<em>HTML</em>2<em>0, r);-    ap</em>rputs(\"<html><head>\\n<title>403 Forbidden</title></head><body><h1>Forbidden</h1>\\n\", r);-    ap<em>rprintf(r, \"<p>You don't have permission to access %s\\n\", ap</em>escape<em>html(r->pool, r->uri));-    ap</em>rprintf(r, \"on this server because you are currently blacklisted by a DNSBL server at: <b>%s</b></p>\\n\", dnsbl);-    ap<em>rputs(\"<hr>\\n\", r);-    ap</em>rprintf(r, \"<address>%s</address>\\n\", ap<em>get</em>server<em>version());-    ap</em>rputs(\"</body></html>\\n\", r);-}- /</em>   * Callback function called on each HTTP request  * Check an IP in a DNSBL@@ -312,9 +301,8 @@         {             ap<em>log</em>rerror(APLOG<em>MARK, APLOG</em>ERR, 0, r,                           \"denied by DNSBL: %s for: %s\", srv<em>elts[i], r->uri);-            r->status = 403;-            generate</em>page(r, srv<em>elts[i]);-            return DONE;+            apr</em>table<em>setn(r->subprocess</em>env, \"defensible\",\"defensible\");+            return OK;         }         else         {@@ -345,16 +333,19 @@ #ifdef HAVE<em>LIBUDNS     struct pollfd pfd;     struct udns</em>cb<em>data **data</em>array<em>elts;-+    int cheesy</em>timeout = 0;     pfd.fd = dns<em>sock(0);     pfd.events = POLLIN;     data</em>array<em>elts = (struct udns</em>cb<em>data **) data</em>array->elts;     /* While we have a queue active <em>/-    while(dns<em>active(&#x26;dns</em>defctx))-        if(poll(&#x26;pfd, 1, dns<em>timeouts(0, -1, 0) * 1000))++    while(dns</em>active(&#x26;dns<em>defctx) &#x26;&#x26; cheesy</em>timeout &#x3C; 150) {+        if(poll(&#x26;pfd, 1, dns<em>timeouts(0, -1, 0)) * 1000)              dns</em>ioevent(0, 0);+\tcheesy<em>timeout++;+    }     dns</em>close(&#x26;dns<em>defctx);@@ -362,9 +353,8 @@     for(i = 0; i &#x3C; data</em>array->nelts; i++)         if(data<em>array</em>elts[i]->blacklist)         {-            r->status = 403;-            generate<em>page(r, data</em>array<em>elts[i]->dnsbl);-            return DONE;+\t    apr</em>table<em>setn(r->subprocess</em>env, \"defensible\",\"defensible\");+\t    return OK;         } #endif@@ -385,7 +375,7 @@ /</em> Register hooks */ static void register<em>hooks(apr</em>pool_t *p <strong>attribute</strong> ((unused))) {-    ap<em>hook</em>access<em>checker(check</em>dnsbl<em>access, NULL, NULL, APR</em>HOOK<em>MIDDLE);+    ap</em>hook<em>fixups(check</em>dnsbl<em>access, NULL, NULL, APR</em>HOOK<em>MIDDLE);     ap</em>hook<em>post</em>config(defensible<em>init, NULL, NULL, APR</em>HOOK_LAST); } </pre></textarea></p>\n<p>Hmm, I worked on this for several more hours tonight and I don't think that ap<em>hook</em>fixups is the appropriate hook for this, but instead think the original one was correct. I was getting some very odd behavior when accessing directories versus files, and when I switched it back to ap<em>hook</em>access_checker, it worked how I expected. There is a lot going on with how the modules talk to each other, and how they are organized in order. Very interesting. It turns out that the first way I got it to work wasn't half bad. It still has a lot of room for improvement though!</p>\n<p>Note - the reason why I changed the hook in the first place was because I thought it was necessary to set an environment variable, but as it turns out it isn't.</p>","frontmatter":{"title":"Server Based Comment Spam Protection"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/2007/2007-10-24-server-based-comment-spam-protection/"}}