<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.742409eb857ab2ccca34.css" data-identity="gatsby-global-css">li{margin-right:1rem}h1,li{display:inline-block}h1{font-style:normal;margin-top:0}header{margin-bottom:1.5rem}header ul{float:right;list-style:none}#wrapper{margin:3em auto;max-width:700px;padding:10px}.blogPostDate{color:#333;font-size:8pt;margin-bottom:9px;padding-top:4px}</style><meta name="generator" content="Gatsby 4.4.0"/><title data-react-helmet="true">Cache with PHP Webservers and Browsers</title><link data-react-helmet="true" rel="canonical" href="https://www.docunext.com/2007/08/cache-with-php-webservers-and-browsers/"/><link as="script" rel="preload" href="/webpack-runtime-910253975eed29c257e8.js"/><link as="script" rel="preload" href="/framework-e27ef662c918f795a5a3.js"/><link as="script" rel="preload" href="/app-578f356f1ad3d3b2b65e.js"/><link as="script" rel="preload" href="/commons-bbb2797d08d51fd1bd26.js"/><link as="script" rel="preload" href="/component---src-templates-blog-post-js-cc8ebf9459c2ce2cf980.js"/><link as="fetch" rel="preload" href="/page-data/2007/08/cache-with-php-webservers-and-browsers/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/2191495970.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/4224293195.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div id="wrapper"><header><ul><li><a href="/about/">About</a></li></ul><a href="/"><h1>Docunext</h1></a></header><hr/><div><h2>Cache with PHP Webservers and Browsers</h2><div class="blogPostDate">August 5th, 2007</div><div><p>Caching is a great boost for performance, but its tough to balance freshness, expiration, and updates. These are the guidelines I follow to help setup caching:</p>
<h3>Decide what is doing the actual serving</h3>
<p>If PHP is serving the content, it should play a role in the caching. If not, it can't! So if you have an image being served that is not touched by PHP, you should definitely setup your web server to support caching, namely HTTP headers and the expires capabilities. Careful though, the expires without checking for modification times can be dangerous, because if content has updated but the client's version of it has not yet expired, they will continue to use the old version.</p>
<h3>Accept that you'll need to cover more than one base</h3>
<p>With the understanding that when you use PHP with a web server you really have two web servers, you will need to have two sets of caching specifications. While it might be possible to contain them in one file and parse out the values, I'm not going to cover that here. In most cases, you'll want your web server like Apache or Lighttpd to pass control of caching to PHP for dynamic content.</p>
<h3>PHP Caching</h3>
<p>There are even more types of PHP caching than there are of HTTP caching. So let's name a few that are involved with PHP:</p>
<ul><li>Opcode caching</li><li>Data source caching (MySQL caching, memcache, xcache var cache, etc)</li><li>Content generation caching</li></ul>
<p>These, combined with HTTP caching, give you so many choices its hard to nail down the best configuration. For this post, I'll just focus on content, and leave the opcode and data source caching for another day.</p>
<p>I usually separate these concepts into two piles: server and client, and the two can benefit each other. If you have content that changes fairly often, forget about it. In my opinion, its not worth it. Leave the caching up to the data source, like MySQL.</p>
<p>If you have content that doesn't change too often, or is client specific, read on!</p>
<p>First off I never use the expires caching feature, its just too much. I may in the future, but I don't right now. I check for modification times. This is very effective, but how do you do so in PHP? Well this is where server caching and client caching unite. If you cache the content on the server, you have a file to test the modification time of. You can then use a PHP script to compare that with the client's last modified time. You'll need to specify a window for saying how long a client cache is good for after the modification time of the server static cache, which is similar to the expires header, but in this case you have a server-controlled cache clearing mechanism: you can delete the server cache file.</p>
<p>This is your rescue! You can program in a trigger to wipe the cache when the seldom updated content is changed, and when the client requested data it has cached, the server checks its freshness against the server cache, finds nothing, rebuilds the content, tells the client that its cache is stale, and sends a new version.</p>
<p>In the case that the client doesn't have a cached copy and the server does, the information will obviously have to be sent. BUT - the server won't have to rebuild it every time, it can just send a static file. On my server, that is the difference of .1 second and .005 seconds.</p>
<p>In my opinion, caching is THE most effective weapon in the fight for efficient web servers. The catch? If configured incorrectly, in is your worst enemy.</p>
<h3>Clearing the cache</h3>
<p>Making caching work is a little easier when you can be certain things have updated or changed, so using a single method for updates is a good idea, like POST. But what about delete? In that case I use an AJAX request to make the post. What if the use has disabled javascript? Then disable caching.</p>
<h3>Unique Caching Problem</h3>
<p>I discovered this bizarre occurrence last night that would cause the server to check the freshness of a cached page, find it fresh, and tell the client it could use its cached version, even though the cached version on the server was just recently cleared and rebuilt. Its hard to explain, but I'll try. <ol><li>Client would make update</li><li>Database updated, cache cleared</li><li>New page rendered, new cache saved</li></ol></p>
<p>If the above transpires in a single request, then a subsequent request will fool the client into thinking that its cached version is still good. I was able to fix the situation by causing an additional request before the last step above with a redirect header to the same page. I think this might be possible to fix with a change to the last modified header that gets send out, but since its working for now, I'll leave it at that and focus on more pressing issues.</p></div></div><div><span>Yearly Indexes: </span><span><a href="/2003/"><span>2003</span></a> </span><span><a href="/2004/"><span>2004</span></a> </span><span><a href="/2006/"><span>2006</span></a> </span><span><a href="/2007/"><span>2007</span></a> </span><span><a href="/2008/"><span>2008</span></a> </span><span><a href="/2009/"><span>2009</span></a> </span><span><a href="/2010/"><span>2010</span></a> </span><span><a href="/2011/"><span>2011</span></a> </span><span><a href="/2012/"><span>2012</span></a> </span><span><a href="/2013/"><span>2013</span></a> </span><span><a href="/2015/"><span>2015</span></a> </span><span><a href="/2019/"><span>2019</span></a> </span><span><a href="/2020/"><span>2020</span></a> </span><span><a href="/2022/"><span>2022</span></a> </span></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/2007/08/cache-with-php-webservers-and-browsers/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-9068a959998310636008.js"],"app":["/app-578f356f1ad3d3b2b65e.js"],"component---src-pages-about-js":["/component---src-pages-about-js-738961a9611f9aa4e8d4.js"],"component---src-pages-games-react-nuzaq-js":["/component---src-pages-games-react-nuzaq-js-50d5da494a82a1aaeb8b.js"],"component---src-pages-index-js":["/component---src-pages-index-js-3aa2421409c5653df938.js"],"component---src-pages-years-js":["/component---src-pages-years-js-d36f319c6c16ef9e8314.js"],"component---src-templates-blog-post-js":["/component---src-templates-blog-post-js-cc8ebf9459c2ce2cf980.js"],"component---src-templates-year-js":["/component---src-templates-year-js-e8af3ddab603f61c6142.js"]};/*]]>*/</script><script src="/polyfill-9068a959998310636008.js" nomodule=""></script><script src="/component---src-templates-blog-post-js-cc8ebf9459c2ce2cf980.js" async=""></script><script src="/commons-bbb2797d08d51fd1bd26.js" async=""></script><script src="/app-578f356f1ad3d3b2b65e.js" async=""></script><script src="/framework-e27ef662c918f795a5a3.js" async=""></script><script src="/webpack-runtime-910253975eed29c257e8.js" async=""></script></body></html>